import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

import static org.apache.tools.ant.taskdefs.condition.Os.*

apply plugin: 'java'
sourceCompatibility = 1.9

def envJavaHome = System.getenv("JDK_HOME")
if (envJavaHome == null || envJavaHome.equals("")) envJavaHome = System.getenv("JAVA_HOME")
def javaHome = envJavaHome == null || envJavaHome.equals("") ? System.getProperty("java.home") : envJavaHome
def javaHomeFile = file(javaHome)
defineProperty("JDK_HOME",
        javaHomeFile.name == "jre" ?
                javaHomeFile.getParent().toString() :
                javaHomeFile.name.startsWith("jre") ?
                        new File(javaHomeFile.getParent(), "jdk1.${javaHomeFile.name.substring(3)}.0").toString() :
                        javaHome) // we have to bail and set it to something and this is as good as any!
ext.JAVA_HOME = JDK_HOME
defineProperty("CONF", "Debug")
defineProperty("JAVA", "$JDK_HOME/bin/java")
defineProperty("RETAIN_PACKAGER_TESTS", "false")
defineProperty("TEST_PACKAGER_DMG", "false")
defineProperty("FULL_TEST", "true")
defineProperty("JDK_JMODS", System.getenv("JDK_JMODS") ?: System.getenv("JDK_HOME") + "/jmods")
ext.IS_MAC = OS_NAME.contains("mac") || OS_NAME.contains("darwin")
ext.IS_WINDOWS = OS_NAME.contains("windows")
ext.IS_LINUX = OS_NAME.contains("linux")
ext.OS_ARCH = System.getProperty("os.arch")
ext.IS_64 = OS_ARCH.toLowerCase().contains("64")
ext.HAS_JAVAFX_MODULES = false
def inStream2 = new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.ProcessBuilder(JAVA, "--list-modules").start().getInputStream()));
try {
    String v;
    while ((v = inStream2.readLine()) != null) {
        v = v.trim();
        if (v.startsWith("javafx.base")) ext.HAS_JAVAFX_MODULES = true;
    }
} finally {
    inStream2.close();
}

project.ext.defaultModuleSourcePath = rootProject.projectDir.path + '/modules/*/src/main/java'
project.ext.defaultModuleSourcePathShim = rootProject.projectDir.path + '/modules/*/src/{main,shims}/java'
ext.EXTRAADDEXPORTS = 'buildSrc/addExports'

repositories {
    mavenCentral()
}

test {
    executable = JAVA
    enableAssertions = true
    scanForTestClasses = false
    include("**/*Test.*")
    testLogging {
        // set options for log level LIFECYCLE
        events TestLogEvent.PASSED, TestLogEvent.SKIPPED,
                TestLogEvent.FAILED, TestLogEvent.STANDARD_OUT
        showExceptions true
        exceptionFormat TestExceptionFormat.FULL
        showCauses true
        showStackTraces true

        // set options for log level DEBUG and INFO
        debug {
            events TestLogEvent.STARTED, TestLogEvent.PASSED,
                    TestLogEvent.SKIPPED, TestLogEvent.FAILED,
                    TestLogEvent.STANDARD_OUT, TestLogEvent.STANDARD_ERROR
        }
        info.events = debug.events
        afterTest { desc, result ->
            if (desc.parent) {
                if (result.getResultType() == TestResult.ResultType.FAILURE) {
                    failedTestSummary += "${desc.getClassName()}#${desc.getName()} FAILED:\n" +
                            "${result.getExceptions()}\n"
                }
            }
        }
        afterSuite { desc, result ->
            if (!desc.parent) { // will match the outermost suite
                def output = "Results: ${result.resultType} (${result.testCount} tests, " +
                        "${result.successfulTestCount} successes, " +
                        "${result.failedTestCount} failures, " +
                        "${result.skippedTestCount} skipped)"
                def startItem = '|  ', endItem = '  |'
                def repeat = startItem + output + endItem
                println('\n' + ('-' * repeat.length()) + '\n' + repeat + '\n' + ('-' * repeat.length()))
                if (result.failedTestCount > 0) {
                    println(failedTestSummary)
                }
            }
        }
    }
    compileTestJava {
    }
}

// Return a list containing the --upgrade-module-path or --module-path
// used with Javac
List<String> computeModulePathArgs(String  pname, List<String> deps, boolean test) {
    List<String> mpa = HAS_JAVAFX_MODULES ? [ '--upgrade-module-path' ] : [ '--module-path' ]
    String mp = null
    deps.each { String projname ->
        def proj = project(projname)
        // for a non test set of args, we don't want the current module in the list
        // for a test test, we do need it to update what we built

        if (proj.hasProperty("moduleName") &&
                proj.buildModule &&
                !(!test && proj.name.equals(pname))) {

            File dir;
            if (test && proj.sourceSets.hasProperty('shims')) {
                dir = new File(proj.sourceSets.shims.java.outputDir, proj.ext.moduleName);
            } else {
                dir = new File(proj.sourceSets.main.java.outputDir, proj.ext.moduleName);
            }
            if (mp == null) {
                mp = dir.path
            } else {
                mp = mp + File.pathSeparator + dir.path
            }
        }
    }

    // in some cases like base we could end up with an empty
    // path... make sure we don't pass one back
    if (mp == null) {
        return null
    }

    mpa += mp

    if (!HAS_JAVAFX_MODULES) {
        String addm = null
        deps.each {String projname ->
            def proj = project(projname)
            // for a non test set of args, we don't want the current module in the list
            // for a test test, we do need it to update what we built

            if (proj.hasProperty("moduleName") &&
                    proj.buildModule &&
                    !(!test && proj.name.equals(pname))) {

                if (addm == null) {
                    addm = proj.moduleName
                } else {
                    addm = addm + "," + proj.moduleName
                }
            }
        }
        if (addm != null) {
            mpa += "--add-modules=${addm}"
        }
    }

    return mpa
}

/**
 * Manages the execution of some closure which is responsible for producing
 * content for a properties file built at build time and stored in the
 * root project's $buildDir, and then loading that properties file and
 * passing it to the processor closure.
 *
 * This is used on windows to produce a properties file containing all the
 * windows visual studio paths and environment variables, and on Linux
 * for storing the results of pkg-config calls.
 *
 * @param name the name of the file to produce
 * @param loader a closure which is invoked, given the properties file. This
 *        closure is invoked only if the properties file needs to be created
 *        and is responsible for populating the properties file.
 * @param processor a closure which is invoked every time this method is
 *        called and which will be given a Properties object, fully populated.
 *        The processor is then responsible for doing whatever it is that it
 *        must do with those properties (such as setting up environment
 *        variables used in subsequent native builds, or whatnot).
 */
void setupTools(String name, Closure loader, Closure processor) {
    // Check to see whether $buildDir/$name.properties file exists. If not,
    // then generate it. Once generated, we need to read the properties file to
    // help us define the defaults for this block of properties
    File propFile = file("$buildDir/${name}.properties");
    if (!propFile.exists()) {
        // Create the properties file
        propFile.getParentFile().mkdirs();
        propFile.createNewFile();
        loader(propFile);
    }

    // Try reading the properties in order to define the properties. If the property file cannot
    // be located, then we will throw an exception because we cannot guess these values
    InputStream propStream = null;
    try {
        Properties properties = new Properties();
        propStream = new FileInputStream(propFile);
        properties.load(propStream);
        processor(properties);
    } finally {
        try { propStream.close() } catch (Exception e) { }
    }
}

/**
 * If the given named property is not defined, then this method will define
 * it with the given defaultValue. Any properties defined by this method can
 * be substituted on the command line by using -P, or by specifying a
 * gradle.properties file in the user home dir
 *
 * @param name The name of the property to define
 * @param defaultValue The default value to assign the property
 */
void defineProperty(String name, String defaultValue) {
    if (!project.hasProperty(name)) {
        project.ext.set(name, defaultValue);
    }
}

/**
 * If the given named property is not defined, then this method will attempt to
 * look up the property in the props map, and use the defaultValue if it cannot be found.
 *
 * @param name The name of the property to look up and/or define
 * @param props The properties to look for the named property in, if it has not already been defined
 * @param defaultValue The default value if the property has not been defined and the
 *                     props map does not contain the named property
 */
void defineProperty(String name, Properties props, String defaultValue) {
    if (!project.hasProperty(name)) {
        project.ext.set(name, props.getProperty(name, defaultValue));
    }
}

// perform common project manipulation for modules
void commonModuleSetup(Project p, List<String> moduleChain) {

    p.ext.moduleChain = moduleChain

    if (p.hasProperty("moduleName")) {
        p.ext.moduleDir = new File (p.sourceSets.main.java.outputDir, "${p.moduleName}")
        if (p.sourceSets.hasProperty('shims')) {
            p.ext.moduleShimsDir = new File (p.sourceSets.shims.java.outputDir, "${p.moduleName}")
        }
    }

    def mpa = computeModulePathArgs(p.name, moduleChain, false)
    if (mpa != null) {
        p.ext.modulePathArgs = mpa
    }

    p.ext.testModulePathArgs = computePatchModuleArgs(moduleChain, true, false)
    p.ext.patchModuleArgs = computePatchModuleArgs(moduleChain ,false, true)
    p.ext.testPatchModuleArgs = computePatchModuleArgs(moduleChain, true, true)

    moduleChain.each() {e ->
        if (!e.equals(p.name)) {
            p.compileJava.dependsOn(project(e).classes)
            p.compileTestJava.dependsOn(project(e).testClasses)
        }
    }

    // read in any addExports file
    File addExportsFile = new File(p.projectDir,"src/test/addExports")
    if (addExportsFile.exists()) {
        List<String> ae = []
        addExportsFile.eachLine { line ->
            line = line.trim()
            if (!(line.startsWith("#") || line.equals(""))) {
                ae += line.split(' ')
            }
        }
        p.ext.testAddExports  = ae.flatten()
    }

    // read in the temporary addExports file EXTRAADDEXPORTS)
    //
    // These extra --add-exports will be used in two places and so we
    // create/modify two items:
    // p.testAddExports - add the extra items so they are included in test builds
    //
    // p.extraAddExports - for use in any other place where we don't automatically update
    //    for example any non modular, non 'test' compile, any compile that does not
    //    use a module-source-path that includes the dependent modules
    //
    // Note that we don't modify the modular build (main, shims) because they use
    // module-info directly, and we don't want to cover up any missing items there.
    //
    if (!rootProject.hasProperty("EXTRA_ADDEXPORTS_ARGS")) {
        List<String> extraAddExportsList = []
        String fullae = ""
        File tmpaddExportsFile = new File(rootProject.projectDir, EXTRAADDEXPORTS)
        if (tmpaddExportsFile.exists()) {
            String nl = System.getProperty("line.separator")
            tmpaddExportsFile.eachLine { line ->
                line = line.trim()
                fullae += line + nl
                if (!(line.startsWith("#") || line.equals(""))) {
                    extraAddExportsList += line.split(' ')
                }
            }
        }
        // This string is used in the creation of the build/*.args files
        // so we preserve comments
        if (!extraAddExportsList.isEmpty()) {
            rootProject.ext.EXTRA_ADDEXPORTS_STRING = fullae
        }
        rootProject.ext.EXTRA_ADDEXPORTS_ARGS = extraAddExportsList
    }

    if (HAS_JAVAFX_MODULES) {
        // use this variable, because it shows we have a non empty addition
        if (rootProject.hasProperty("EXTRA_ADDEXPORTS_STRING")) {
            p.ext.extraAddExports = EXTRA_ADDEXPORTS_ARGS.flatten()
            if (p.hasProperty("testAddExports")) {
                p.testAddExports += EXTRA_ADDEXPORTS_ARGS.flatten()
            }
        }
    }
}
// Return list with the arguments needed for --patch-module or --module-path
// for the provided projects. Used with Java executables ie. tests
List<String> computePatchModuleArgs(List<String> deps, boolean test, boolean includeJLP) {
    List<String> pma = []

    if (HAS_JAVAFX_MODULES) {
        deps.each { String projname ->
            def proj = project(projname)
            if (proj.hasProperty("moduleName")) {
                File dir;
                if (test && proj.sourceSets.hasProperty('shims')) {
                    dir = file("${rootProject.buildDir}/shims")
                } else {
                    dir = file("${rootProject.buildDir}/modular-sdk/modules")
                }
                String moduleName = proj.ext.moduleName
                String dirpath = "${dir}/${moduleName}"
                pma += "--patch-module=${moduleName}=${dirpath}"
            }
        }
    } else {
        String mp = null
        deps.each { String projname ->
            def proj = project(projname)
            if (proj.hasProperty("moduleName")) {
                String moduleName = proj.ext.moduleName
                File dir;
                if (test && proj.sourceSets.hasProperty('shims')) {
                    dir = file("${rootProject.buildDir}/shims/${moduleName}")
                } else {
                    dir = file("${rootProject.buildDir}/sdk/lib/${moduleName}.jar")
                }
                if (mp == null) {
                    mp = dir.path
                } else {
                    mp = mp + File.pathSeparator + dir.path
                }
            }
        }

        // in some cases like base we could end up with an empty
        // path... make sure we don't pass one back
        if (mp == null) {
            return null
        }

        pma += '--module-path'
        pma += mp

        String addm = null
        deps.each {String projname ->
            def proj = project(projname)
            if (proj.hasProperty("moduleName") && proj.buildModule) {
                if (addm == null) {
                    addm = proj.moduleName
                } else {
                    addm = addm + "," + proj.moduleName
                }
            }
        }
        if (addm != null) {
            pma += "--add-modules=${addm}"
        }
    }

    return pma
}

subprojects {
    apply plugin: "java"
}

project(":fxpackagerservices") {
    project.ext.buildModule = true
    project.ext.includeSources = true
    project.ext.moduleRuntime = false
    project.ext.moduleName = "jdk.packager.services"

    sourceSets {
        main
        test
    }

    project.ext.moduleSourcePath = defaultModuleSourcePath
    project.ext.moduleSourcePathShim = defaultModuleSourcePathShim

    // commonModuleSetup(project, [ 'base', 'graphics', 'controls' ])

    compileTestJava.enabled = false // FIXME: JIGSAW -- support this with modules

    test {
        enabled = false // FIXME: JIGSAW -- support this with modules
        logger.info("JIGSAW Testing disabled for fxpackagerservices")
    }
}

project(":fxpackager") {
    project.ext.buildModule = true
    project.ext.includeSources = true
    project.ext.moduleName = "jdk.packager"
    project.ext.moduleRuntime = false
    project.ext.moduleSourcePath = defaultModuleSourcePath
    project.ext.moduleSourcePathShim = defaultModuleSourcePathShim

    sourceSets {
        main
        antplugin {
            java {
                compileClasspath += main.output
                runtimeClasspath += main.output
            }
        }
        test
    }

    commonModuleSetup(project, [ 'fxpackagerservices', 'fxpackager' ])

    manifest {
        attributes(
                "Main-Class": "com.sun.openjfx.tools.packager.Main"
        )
    }

    repositories {
        mavenCentral()
        maven {
            url "https://repository.apache.org"
        }
    }

    dependencies {
        testCompile group: "junit", name: "junit", version: "4.8.2"
        antpluginCompile group: "org.apache.ant", name: "ant", version: "1.8.2"
        testCompile project(":fxpackager"),
                group: "org.apache.ant", name: "ant", version: "1.8.2",
                sourceSets.antplugin.output
    }

    //Note: these should be reflected in the module-info additions passed to the JDK
    compileJava.options.compilerArgs.addAll([
            "--add-exports=java.base/sun.security.timestamp=jdk.packager",
            "--add-exports=java.base/sun.security.x509=jdk.packager",

            // Note: retain jdk.jlink qualified export for cases where the JDK does
            // not contain the jdk.packager module.
            "--add-exports=jdk.jlink/jdk.tools.jlink.internal.packager=jdk.packager",

            // Note: not in extras...
            "--add-exports=java.base/sun.security.pkcs=jdk.packager",
            "--add-exports=java.logging/java.util.logging=jdk.packager",
    ])

    compileAntpluginJava.dependsOn([ compileJava, processResources ])
    compileAntpluginJava.options.compilerArgs.addAll(computeModulePathArgs("antlib", project.moduleChain, false))


    task buildVersionFile() {
        File dir = new File("${project.projectDir}/build/resources/antplugin/resources");
        File versionFile = new File(dir, "/version.properties");
        doLast {
            dir.mkdirs()
            if (!versionFile.exists()) {
                versionFile << "version=0.0.1\n"
            }
        }
        outputs.file(versionFile)
    }

    // When producing the ant-javafx.jar, we need to relocate a few class files
    // from their normal location to a resources/classes or resources/web-files
    // location
    task antpluginJar(type: Jar, dependsOn: [ compileJava, jar, compileAntpluginJava, buildVersionFile ]) {
        includeEmptyDirs = false
        archiveName = "ant-javafx.jar"

        from (sourceSets.antplugin.output) {
            eachFile { FileCopyDetails details ->
                if (details.path.startsWith("com/javafx/main")) {
                    details.path = "resources/classes/$details.path"
                }
            }
        }

        from (sourceSets.main.resources) {
            includes = [ "com/sun/javafx/tools/ant/**" ]
        }

        from (sourceSets.main.output.resourcesDir) {
            includes = [ "resources/web-files/**" ]
        }
    }

    assemble.dependsOn(antpluginJar)

    if (IS_WINDOWS) {
        setupTools("windows_tools",
            { propFile ->
                // Create the properties file
                ByteArrayOutputStream results = new ByteArrayOutputStream();
                String winsdkDir = System.getenv().get("WINSDK_DIR");
                exec({
                    environment([
                            "WINSDKPATH" : winsdkDir == null ? "" : winsdkDir,
                            "CONF"       : "/$CONF", // TODO does this mean the generated properties must be reset when in a different configuration?
                            "VCARCH"     : IS_64 ? "amd64" : "x86",
                            "SDKARCH"    : IS_64 ? "/x64" : "/x86",
                    ]);
                    commandLine("cmd", "/q", "/c", "genVSproperties.bat");
                    setStandardOutput(results);
                });
                BufferedReader reader = new BufferedReader(new StringReader(results.toString().trim()));
                reader.readLine();
                reader.readLine();
                String line;
                while ((line = reader.readLine()) != null && !line.startsWith("######")) {
                    line = line.replace("\\", "/").replace("/@@ENDOFLINE@@", "").replace("@@ENDOFLINE@@", "").replace("//", "/").replace("windows.vs.", "WINDOWS_VS_");
                    propFile << line << "\r\n";
                }
            },
            { properties ->
                defineProperty("WINDOWS_VS_VSINSTALLDIR", properties, "c:/Program Files (x86)/Microsoft Visual Studio/2017/Professional");
                defineProperty("WINDOWS_VS_WINSDKDLLINSTALLDIR", properties, "c:/Program Files (x86)/Windows Kits/10/Redist/ucrt/DLLs");
                defineProperty("WINDOWS_SDK_DIR", properties, System.getenv().get("WINSDK_DIR"))
                defineProperty("WINDOWS_SDK_VERSION", properties, "")
                defineProperty("WINDOWS_VS_VCINSTALLDIR", properties, "$WINDOWS_VS_VSINSTALLDIR/VC")
                defineProperty("WINDOWS_VS_DEVENVDIR", properties, "$WINDOWS_VS_VSINSTALLDIR/Common7/IDE")
                defineProperty("WINDOWS_VS_DEVENVCMD", properties, "$WINDOWS_VS_DEVENVDIR/VCExpress.exe")
                defineProperty("WINDOWS_VS_MSVCDIR", properties, WINDOWS_VS_VCINSTALLDIR)
                defineProperty("WINDOWS_DXSDK_DIR", properties, System.getenv().get("DXSDK_DIR"))
                defineProperty("WINDOWS_VS_INCLUDE", properties, "$WINDOWS_VS_VCINSTALLDIR/INCLUDE;" + "$WINDOWS_SDK_DIR/include;")
                defineProperty("WINDOWS_VS_VER", properties, "150")
                defineProperty("WINDOWS_VS_LIB", properties, "$WINDOWS_VS_VCINSTALLDIR/LIB;" + "$WINDOWS_SDK_DIR/lib;")
                defineProperty("WINDOWS_VS_LIBPATH", properties, "$WINDOWS_VS_VCINSTALLDIR/LIB;")
                defineProperty("WINDOWS_VS_PATH", properties, "$WINDOWS_VS_DEVENVDIR;" +
                        "$WINDOWS_VS_VSINSTALLDIR/VC/BIN;" +
                        "$WINDOWS_VS_VSINSTALLDIR/Common7/Tools;" +
                        "$WINDOWS_VS_VCINSTALLDIR/VCPackages;" +
                        "$WINDOWS_SDK_DIR/bin/NETFX 4.0 Tools;" +
                        "$WINDOWS_SDK_DIR/bin;" +
                        System.getenv().get("PATH"))
            }
        )

        if (WINDOWS_SDK_DIR == null || WINDOWS_SDK_DIR == "") {
            throw new GradleException("FAIL: WINSDK_DIR not defined");
        }

        ext.WINDOWS_NATIVE_COMPILE_ENVIRONMENT = [
                "VCINSTALLDIR"         : WINDOWS_VS_VCINSTALLDIR,
                "VSINSTALLDIR"         : WINDOWS_VS_VSINSTALLDIR,
                "DEVENVDIR"            : WINDOWS_VS_DEVENVDIR,
                "MSVCDIR"              : WINDOWS_VS_MSVCDIR,
                "VS_VER"               : WINDOWS_VS_VER,
                "PATH"                 : WINDOWS_VS_PATH,
                "INCLUDE"              : WINDOWS_VS_INCLUDE,
                "LIB"                  : WINDOWS_VS_LIB,
                "LIBPATH"              : WINDOWS_VS_LIBPATH,
                "DXSDK_DIR"            : WINDOWS_DXSDK_DIR
        ];

        ext.WIN = [:]
        WIN.fxpackager = [:]
        WIN.fxpackager.nativeSource = [
            file("modules/jdk.packager/src/main/native/javapackager/win")]
        WIN.fxpackager.compiler = compiler
        WIN.fxpackager.ccFlags = ["/nologo", "/W3", "/EHsc", "/MT", "/GS",  "/DUNICODE", "/D_UNICODE",
                            "/DWIN32", "/D_LITTLE_ENDIAN", "/DWIN32_LEAN_AND_MEAN",
                            "/D_WIN32_WINDOWS=0X0500", "/D_WIN32_WINNT=0X0500",
                            "/I$JDK_HOME/include", "/I$JDK_HOME/include/win32",
                            "/O2", "-c"]
        WIN.fxpackager.linker = linker
        WIN.fxpackager.linkFlags = ["/nologo", "/SUBSYSTEM:CONSOLE", "/opt:REF", "/incremental:no", "/manifest", "kernel32.lib", "advapi32.lib"];
        WIN.fxpackager.rcSource = file("modules/jdk.packager/src/main/native/javapackager/win/javapackager.rc")
        WIN.fxpackager.rcCompiler = rcCompiler
        WIN.fxpackager.rcFlags = [
            "/l", "0x409",
            "/d", "JFX_FNAME=javapackager.exe",
            "/d", "JFX_INTERNAL_NAME=javapackager",
        rcFlags].flatten();
    }

    // Builds the javapackager executable. For everything other than windows,
    // this is simply moving the existing shell script and ensuring it has proper
    // permissions. For Windows, this includes compiling the native executable
    if (IS_WINDOWS){
        task setupCompileJavaPackager(type: Copy, group: "Build") {
            mkdir "$buildDir/native"
            mkdir "$buildDir/native/javapackager"
            from file("src/main/native/javapackager/win/javapackager.manifest")
            into file("$buildDir/native/javapackager")
            filter { line->
                line = line.replace("FXVERSION", "v0.0.1")
            }
        }

        task compileJavaPackager(type: CCTask, group: "Build", dependsOn: setupCompileJavaPackager) {
            description = "Compiles native sources for javapackager.exe"
            matches = ".*\\.cpp"
            params.addAll(WIN.fxpackager.ccFlags)
            compiler = WIN.fxpackager.compiler
            output(file("$buildDir/native/javapackager/obj"))
            source WIN.fxpackager.nativeSource
            doLast {
                mkdir "$buildDir/native"
                exec {
                    environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                    commandLine(WIN.fxpackager.rcCompiler)
                    args(WIN.fxpackager.rcFlags)
                    args("/fo$buildDir/native/javapackager/javapackager.res")
                    args(WIN.fxpackager.rcSource)
                }
            }
        }

        task linkJavaPackager(type: LinkTask, dependsOn: compileJavaPackager, group: "Build") {
            description = "Links javapackager.exe"
            objectDir = file("$buildDir/native/javapackager/obj")
            linkParams.addAll(WIN.fxpackager.linkFlags);
            lib = file("$buildDir/native/javapackager/javapackager.exe")
            linker = WIN.fxpackager.linker
            doLast {
                exec({
                    commandLine("$MC", "-manifest",
                                       "$buildDir/native/javapackager/javapackager.manifest",
                                       "-outputresource:$buildDir/native/javapackager/javapackager.exe")
                    environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                })
            }
        }

        task copyJavaPackager(type: Copy, group: "Build", dependsOn: linkJavaPackager) {
            from file("$buildDir/native/javapackager/javapackager.exe")
            into file("$buildDir/javapackager")
        }

        task buildJavaPackager(dependsOn: [copyJavaPackager])
    } else {
        task buildJavaPackager(type: Copy, group: "Build") {
            enabled = true
            from "src/main/native/javapackager/shell"
            into "$buildDir/javapackager"
            fileMode = 0755
        }
    }

    assemble.dependsOn buildJavaPackager

    task setupPackagerFakeJar(type: Copy) {
        from "$projectDir/src/main/resources/com/oracle/tools/packager/linux/javalogo_white_48.png"
        from "$projectDir/src/main/resources/com/oracle/tools/packager/mac/GenericAppHiDPI.icns"
        from "$projectDir/src/main/resources/com/oracle/tools/packager/windows/javalogo_white_48.ico"
        from "$projectDir/src/test/resources/hello/java-logo2.gif"
        from "$projectDir/src/test/resources/hello/small.ico"
        from "$projectDir/src/test/resources/hello/test.icns"
        from "$projectDir/src/test/resources/hello/LICENSE-RTF.rtf"
        into project.file("$projectDir/build/tmp/tests/appResources")
    }


    task packagerFakeJar(type: Jar, dependsOn: [setupPackagerFakeJar]) {
        dependsOn compileTestJava
        from compileTestJava.destinationDir
        include "hello/**"

        destinationDir project.file("build/tmp/tests/appResources")
        archiveName "mainApp.jar"

        manifest {
            attributes(
                    "Main-Class": "hello.HelloRectangle",
                    "Custom-Attribute": " Is it stripped?"
            )
        }
    }

    task packagerFXPackagedJar(type: Jar) {
        dependsOn packagerFakeJar
        from compileTestJava.destinationDir
        include "hello/**"

        destinationDir project.file("build/tmp/tests/appResources")
        archiveName "packagedMainApp.jar"

        manifest {
            attributes(
                    "JavaFX-Application-Class": "hello.TestPackager",
            )
        }
    }

    compileTestJava.enabled = false // FIXME: JIGSAW -- support this with modules
    test {
        enabled = false // FIXME: JIGSAW -- support this with modules
        logger.info("JIGSAW Testing disabled for fxpackager")

        dependsOn packagerFXPackagedJar
        systemProperty "RETAIN_PACKAGER_TESTS", RETAIN_PACKAGER_TESTS
        systemProperty "TEST_PACKAGER_DMG", TEST_PACKAGER_DMG
        systemProperty "FULL_TEST", FULL_TEST
        executable = JAVA;
    }

    def packagerDevOpts = []
    try {
        packagerDevOpts.addAll(PACKAGER_DEV_OPTS.split(' '))
    } catch (MissingPropertyException ignore) {
        packagerDevOpts.addAll("image")
    }

    task packagerDev(dependsOn: [jar, testClasses, packagerFakeJar], type:JavaExec) {
        workingDir = project.file("build/tmp/tests/appResources/")
        executable = JAVA
        classpath = project.files("build/libs/ant-javafx.jar", "build/classes/test", "build/resources/test")
        main = "hello.SimpleBundle"
        args = [
                '--module-path', JDK_JMODS,
                '-o', "$projectDir/build/dev",
                '-all',
                packagerDevOpts
        ].flatten()
    }

    task createPackagerServicesModule(type: Jar) {
        if (project.hasProperty("DEBUGJDK_HOME")) {
            def dir = file("$DEBUGJDK_HOME/newmodules")
            dir.mkdirs()

            includeEmptyDirs = false
            archiveName = "jdk.packager.services.jar"
            destinationDir = dir

            from (project.file("$rootProject.buildDir/modular-sdk/modules/jdk.packager.services")) {
                include "**"
            }

            from (project.file("$rootProject.buildDir/../modules/jdk.packager/build/classes/java/main/jdk.packager.services")) {
                include "module-info.class"
            }
        }
    }

    task createPackagerModule(type: Jar) {
        if (project.hasProperty("DEBUGJDK_HOME")) {
            def dir = file("$DEBUGJDK_HOME/newmodules")
            dir.mkdirs()

            includeEmptyDirs = false
            archiveName = "jdk.packager.jar"
            destinationDir = dir

            from (project.file("$rootProject.buildDir/modular-sdk/modules/jdk.packager")) {
                include "**"
            }

            from (project.file("$rootProject.buildDir/../modules/jdk.packager/build/classes/java/main/jdk.packager")) {
                include "module-info.class"
            }
        }
    }

    task createRunScript() {
        def TEXT = "DEBUG_ARG=\"-J-Xdebug:\"\n" +
                "\n" +
                "# Argument parsing.\n" +
                "ARGS=()\n" +
                "for i in \"\$@\"; do\n" +
                "    if [[ \"\$i\" == \${DEBUG_ARG}* ]]; then\n" +
                "        ADDRESS=\${i:\${#DEBUG_ARG}}\n" +
                "        DEBUG=\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=\${ADDRESS}\"\n" +
                "    else\n" +
                "        ARGS+=(\"\$i\")\n" +
                "    fi\n" +
                "done\n" +
                "\n" +
                "\${JAVA_HOME}/bin/java.original --upgrade-module-path \${JAVA_HOME}/newmodules \$(IFS=\$\' \'; echo \"\${ARGS[*]}\")\n"

        doLast {
            new File("$DEBUGJDK_HOME/bin").mkdirs()
            def runscript = new File("$DEBUGJDK_HOME/bin/java")//.withWriter('utf-8') //{
            runscript.write(TEXT)
        }

        doLast {
            exec {
                commandLine('chmod',  '+x', "$DEBUGJDK_HOME/bin/java")
            }
        }
    }

    task createBuildScript() {
        def TEXT = "DEBUG_ARG=\"-J-Xdebug:\"\n" +
                "\n" +
                "# Argument parsing.\n" +
                "ARGS=()\n" +
                "for i in \"\$@\"; do\n" +
                "    if [[ \"\$i\" == \${DEBUG_ARG}* ]]; then\n" +
                "        ADDRESS=\${i:\${#DEBUG_ARG}}\n" +
                "        DEBUG=\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=\${ADDRESS}\"\n" +
                "    else\n" +
                "        ARGS+=(\"\$i\")\n" +
                "    fi\n" +
                "done\n" +
                "\n" +
                "\${JAVA_HOME}/bin/javac.original --upgrade-module-path \${JAVA_HOME}/newmodules \$(IFS=\$\' \'; echo \"\${ARGS[*]}\")\n"

        doLast {
            new File("$DEBUGJDK_HOME/bin").mkdirs()
            def buildscript = new File("$DEBUGJDK_HOME/bin/javac")//.withWriter('utf-8') //{
            buildscript.write(TEXT)
        }

        doLast {
            exec {
                commandLine('chmod',  '+x', "$DEBUGJDK_HOME/bin/javac")
            }
        }
    }

    task createDebugJDK(dependsOn: [createPackagerModule, createPackagerServicesModule, createRunScript, createBuildScript]) {
        def EXE = IS_WINDOWS ? ".exe" : ""

        doLast {
            copy {
                from SOURCEJDK_HOME
                into DEBUGJDK_HOME
                exclude("*/ant-javafx.jar")
                exclude("*/javapackager$EXE")
                exclude("*/java$EXE")
                exclude("*/javac$EXE")
                exclude("*/jdk.packager.services.jmod")
            }

            copy {
                from "$SOURCEJDK_HOME/bin/java$EXE"
                into "$DEBUGJDK_HOME/bin"
                rename "java$EXE", "java.original$EXE"
            }

            copy {
                from "$SOURCEJDK_HOME/bin/javac$EXE"
                into "$DEBUGJDK_HOME/bin"
                rename "javac$EXE", "javac.original$EXE"
            }

            copy {
                from "$rootProject.buildDir/modular-sdk/modules_libs/jdk.packager/ant-javafx.jar"
                into "$DEBUGJDK_HOME/lib"
            }

            copy {
                from "$rootProject.buildDir/modular-sdk/modules_cmds/jdk.packager/javapackager$EXE"
                into "$DEBUGJDK_HOME/bin"
            }

            copy {
                from "$DEBUGJDK_HOME/newmodules/jdk.packager.services.jar"
                into "$DEBUGJDK_HOME/jmods"
            }
        }
    }

    task copyRedistributableFiles(type: Copy) {
        def projectDir = "tools/java/legacy"
        def sourceDir = "src/$projectDir"
        def buildDir = "build/$projectDir"
        def resourceDir = "${moduleDir}/jdk/packager/internal/resources/tools/legacy"

        from "$sourceDir/jre.list"
        into project.file("$resourceDir")
    }

    processResources.dependsOn copyRedistributableFiles

    task copyDTtoPackager(type: Copy) {
        def destDt = "${moduleDir}/com/sun/javafx/tools/resource"
        from (sourceSets.main.output.resourcesDir) {
            includes = [ "resources/web-files/**" ]
        }
        into new File("$destDt", "dtoolkit")
    }

    processResources.dependsOn copyDTtoPackager
}
